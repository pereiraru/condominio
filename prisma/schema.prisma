generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Users (admin and residents)
model User {
  id           String    @id @default(cuid())
  email        String    @unique
  passwordHash String
  name         String?
  role         String    @default("user") // "admin" or "user"
  unitId       String?   @unique // 1:1 with unit
  unit         Unit?     @relation(fields: [unitId], references: [id])
  ownerId      String?
  owner        Owner?    @relation(fields: [ownerId], references: [id])
  lastLogin    DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
}

// Building units (apartments)
model Unit {
  id           String        @id @default(cuid())
  code         String        @unique // e.g., "1D", "1E", "2D", "RCE", "CV"
  floor        Int?
  description  String?
  monthlyFee   Float         @default(45.0)
  nib          String?
  telefone     String?
  email        String?
  user                User?
  owners              Owner[]
  transactions        Transaction[]
  feeHistory          FeeHistory[]
  extraCharges        ExtraCharge[]
  descriptionMappings DescriptionMapping[]
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
}

// Unit owners/residents (multiple per unit, with ownership periods)
model Owner {
  id         String   @id @default(cuid())
  name       String
  email      String?
  telefone   String?
  nib        String?
  startMonth String?  // "YYYY-MM" - null = from the beginning
  endMonth   String?  // "YYYY-MM" - null = current owner
  previousDebt Float    @default(0)
  unitId     String
  unit       Unit     @relation(fields: [unitId], references: [id], onDelete: Cascade)
  users      User[]
  createdAt  DateTime @default(now())
}

// Creditors (suppliers, service providers)
model Creditor {
  id          String               @id @default(cuid())
  name        String
  description String?
  category    String               // "electricity", "water", "gas", "maintenance", "insurance", "cleaning", "other"
  amountDue   Float?               // expected regular amount
  email       String?
  telefone    String?
  nib         String?
  attachments         CreditorAttachment[]
  transactions        Transaction[]
  feeHistory          FeeHistory[]
  descriptionMappings DescriptionMapping[]
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
}

// Creditor attachments (invoices, contracts)
model CreditorAttachment {
  id         String   @id @default(cuid())
  creditorId String
  creditor   Creditor @relation(fields: [creditorId], references: [id], onDelete: Cascade)
  name       String
  filename   String
  mimeType   String
  size       Int
  uploadedAt DateTime @default(now())
}

// Financial transactions (expenses and payments)
model Transaction {
  id               String             @id @default(cuid())
  date             DateTime
  valueDate        DateTime?
  description      String
  amount           Float              // positive = income, negative = expense
  balance          Float?
  type             String             // "payment", "expense", "fee", "transfer"
  category         String?            // "electricity", "maintenance", "bank_fee", "savings", etc.
  referenceMonth   String?            // "YYYY-MM" - legacy, kept for compatibility
  unitId           String?
  unit             Unit?              @relation(fields: [unitId], references: [id])
  creditorId       String?
  creditor         Creditor?          @relation(fields: [creditorId], references: [id])
  documentId       String?
  document         Document?          @relation(fields: [documentId], references: [id])
  monthAllocations TransactionMonth[]
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
}

// Month allocations for transactions (split a single transaction across multiple months)
model TransactionMonth {
  id            String       @id @default(cuid())
  transactionId String
  transaction   Transaction  @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  month         String       // "YYYY-MM"
  amount        Float        // amount allocated to this month
  extraChargeId String?      // null = base fee, non-null = extra charge payment
  extraCharge   ExtraCharge? @relation(fields: [extraChargeId], references: [id], onDelete: SetNull)
  createdAt     DateTime     @default(now())
}

// Documents (invoices, receipts, minutes)
model Document {
  id           String        @id @default(cuid())
  name         String
  filename     String
  mimeType     String
  size         Int
  category     String        // "invoice", "receipt", "minutes", "contract", "other"
  description  String?
  transactions Transaction[]
  uploadedAt   DateTime      @default(now())
}

// Description pattern mapping for auto-assigning transactions
model DescriptionMapping {
  id         String   @id @default(cuid())
  pattern    String   @unique // substring to match in transaction descriptions
  unitId     String?
  creditorId String?
  createdAt  DateTime @default(now())

  unit     Unit?     @relation(fields: [unitId], references: [id], onDelete: Cascade)
  creditor Creditor? @relation(fields: [creditorId], references: [id], onDelete: Cascade)
}

// Fee history - tracks fee changes with effective dates
model FeeHistory {
  id            String    @id @default(cuid())
  unitId        String?
  creditorId    String?
  amount        Float
  effectiveFrom String    // "YYYY-MM" format
  effectiveTo   String?   // "YYYY-MM" format, null means ongoing
  createdAt     DateTime  @default(now())

  unit     Unit?     @relation(fields: [unitId], references: [id], onDelete: Cascade)
  creditor Creditor? @relation(fields: [creditorId], references: [id], onDelete: Cascade)
}

// Extra charges - additional fees for specific periods (repairs, improvements, etc.)
model ExtraCharge {
  id            String    @id @default(cuid())
  unitId        String?   // null means applies to all units
  description   String    // e.g., "Reparação bomba de água"
  amount        Float     // extra amount to add to monthly fee
  effectiveFrom String    // "YYYY-MM" format
  effectiveTo   String?   // "YYYY-MM" format, null means ongoing
  createdAt     DateTime  @default(now())

  unit              Unit?              @relation(fields: [unitId], references: [id], onDelete: Cascade)
  transactionMonths TransactionMonth[]
}
