generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Users (admin and residents)
model User {
  id           String   @id @default(cuid())
  email        String   @unique
  passwordHash String
  name         String
  role         String   @default("resident") // "admin" or "resident"
  unitId       String?
  unit         Unit?    @relation(fields: [unitId], references: [id])
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

// Building units (apartments)
model Unit {
  id           String        @id @default(cuid())
  code         String        @unique // e.g., "1D", "1E", "2D", "RCE", "CV"
  floor        Int?
  description  String?
  monthlyFee   Float         @default(45.0)
  nib          String?
  telefone     String?
  email        String?
  residents           User[]
  owners              Owner[]
  transactions        Transaction[]
  feeHistory          FeeHistory[]
  descriptionMappings DescriptionMapping[]
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
}

// Unit owners/residents (multiple per unit)
model Owner {
  id        String   @id @default(cuid())
  name      String
  unitId    String
  unit      Unit     @relation(fields: [unitId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

// Creditors (suppliers, service providers)
model Creditor {
  id          String               @id @default(cuid())
  name        String
  description String?
  category    String               // "electricity", "water", "gas", "maintenance", "insurance", "cleaning", "other"
  amountDue   Float?               // expected regular amount
  email       String?
  telefone    String?
  nib         String?
  attachments         CreditorAttachment[]
  transactions        Transaction[]
  feeHistory          FeeHistory[]
  descriptionMappings DescriptionMapping[]
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
}

// Creditor attachments (invoices, contracts)
model CreditorAttachment {
  id         String   @id @default(cuid())
  creditorId String
  creditor   Creditor @relation(fields: [creditorId], references: [id], onDelete: Cascade)
  name       String
  filename   String
  mimeType   String
  size       Int
  uploadedAt DateTime @default(now())
}

// Financial transactions (expenses and payments)
model Transaction {
  id             String    @id @default(cuid())
  date           DateTime
  valueDate      DateTime?
  description    String
  amount         Float     // positive = income, negative = expense
  balance        Float?
  type           String    // "payment", "expense", "fee", "transfer"
  category       String?   // "electricity", "maintenance", "bank_fee", "savings", etc.
  referenceMonth String?   // "YYYY-MM" - which month this payment/expense covers
  unitId         String?
  unit           Unit?     @relation(fields: [unitId], references: [id])
  creditorId     String?
  creditor       Creditor? @relation(fields: [creditorId], references: [id])
  documentId     String?
  document       Document? @relation(fields: [documentId], references: [id])
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
}

// Documents (invoices, receipts, minutes)
model Document {
  id           String        @id @default(cuid())
  name         String
  filename     String
  mimeType     String
  size         Int
  category     String        // "invoice", "receipt", "minutes", "contract", "other"
  description  String?
  transactions Transaction[]
  uploadedAt   DateTime      @default(now())
}

// Description pattern mapping for auto-assigning transactions
model DescriptionMapping {
  id         String   @id @default(cuid())
  pattern    String   @unique // substring to match in transaction descriptions
  unitId     String?
  creditorId String?
  createdAt  DateTime @default(now())

  unit     Unit?     @relation(fields: [unitId], references: [id], onDelete: Cascade)
  creditor Creditor? @relation(fields: [creditorId], references: [id], onDelete: Cascade)
}

// Fee history - tracks fee changes with effective dates
model FeeHistory {
  id            String    @id @default(cuid())
  unitId        String?
  creditorId    String?
  amount        Float
  effectiveFrom String    // "YYYY-MM" format
  createdAt     DateTime  @default(now())

  unit     Unit?     @relation(fields: [unitId], references: [id], onDelete: Cascade)
  creditor Creditor? @relation(fields: [creditorId], references: [id], onDelete: Cascade)
}
